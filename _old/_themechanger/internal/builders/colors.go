/*
 * Supplying a real world example so you get the hang of how nesting can
 * be written.
 *
 *         type Service struct {
 *                 APIVersion string `yaml:"apiVersion"`
 *                 Kind       string `yaml:"kind"`
 *                 Metadata   struct {
 *                         Name      string `yaml:"name"`
 *                         Namespace string `yaml:"namespace"`
 *                         Labels    struct {
 *                                 RouterDeisIoRoutable string
 * `yaml:"router.deis.io/routable"`
 *                         } `yaml:"labels"`
 *                         Annotations struct {
 *                                 RouterDeisIoDomains string
 * `yaml:"router.deis.io/domains"`
 *                         } `yaml:"annotations"`
 *                 } `yaml:"metadata"`
 *                 Spec struct {
 *                         Type     string `yaml:"type"`
 *                         Selector struct {
 *                                 App string `yaml:"app"`
 *                         } `yaml:"selector"`
 *                         Ports []struct {
 *                                 Name       string `yaml:"name"`
 *                                 Port       int    `yaml:"port"`
 *                                 TargetPort int    `yaml:"targetPort"`
 *                                 NodePort   int
 * `yaml:"nodePort,omitempty"`
 *                         } `yaml:"ports"`
 *                 } `yaml:"spec"`
 *         }
 *
 * There's a convenient service called yaml-to-go https:yaml.to-
 * go.online/ which converts YAML to go structs, just input your YAML
 * into that service and you get an autogenerated struct.
 *
 * And last unmarshal as a previous poster wrote:
 */
package builders

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"path/filepath"
	"text/template"

	"github.com/goccy/go-yaml"
)

type Colors struct {
	Bg  string `yaml:"bg"`
	Bg2 string `yaml:"bg2"`
}

type ColorBuilder struct {
	scheme string
	repo   string
}

func NewColorBuilder(scheme string, repo string) *ColorBuilder {
	return &ColorBuilder{scheme: scheme, repo: repo}
}

func (b *ColorBuilder) GetColors() (map[string]string, error) {
	var res Colors

	f, err := os.Open(filepath.Join(b.repo, "_colors", fmt.Sprintf("%s.yaml", b.scheme)))
	if err != nil {
		return nil, fmt.Errorf("open color-file: %w", err)
	}

	data, err := io.ReadAll(f)
	if err != nil {
		return nil, fmt.Errorf("reading color-file: %w", err)
	}

	err = yaml.Unmarshal(data, &res)
	if err != nil {
		panic(err)
	}

	return map[string]string{
		"bg":  res.Bg,
		"bg2": res.Bg2,
	}, nil
}

func (b *ColorBuilder) ParseString(input string) (string, error) {
	t, err := template.New("colorscheme").Parse(input)
	if err != nil {
		return "", fmt.Errorf("parsing string: %w", err)
	}

	var buf bytes.Buffer
	vars, err := b.GetColors()
	if err != nil {
		return "", fmt.Errorf("parseString: %w", err)
	}

	err = t.Execute(&buf, vars)
	if err != nil {
		return "", fmt.Errorf("executing template: %w", err)
	}

	return buf.String(), nil

}

// func (*b) ParseString(input string) (string, error) {
//
// 	return "", nil
// }
//
// func (*b) ParseFile(input string) (string, error) {
// 	return "", nil
// }

//
// var service Service
//
// err = yaml.Unmarshal(yourFile, &service)
// if err != nil {
//     panic(err)
// }
//
// fmt.Print(service.Metadata.Name)

// [JazzCat] [so/q/28682439] [cc by-sa 3.0]
